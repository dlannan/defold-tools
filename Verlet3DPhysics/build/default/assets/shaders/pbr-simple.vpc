
ž
™
#version 140






#ifndef GL_ES
#define lowp
#define mediump
#define highp
#endif

#line 5
in highp vec4 position;
in mediump vec2 texcoord0;
in mediump vec3 normal;

uniform mediump mat4 mtx_world;
uniform mediump mat4 mtx_worldview;
uniform mediump mat4 mtx_view;
uniform mediump mat4 mtx_proj;
uniform mediump mat4 mtx_normal;
uniform mediump vec4 light;








out vec3 vvLocalSurfaceNormal ;
out vec3 vvLocalSurfaceToLightDirection;
out vec3 vvLocalReflectedSurfaceToViewerDirection;
out vec3 vvLocalSurfaceToViewerDirection;
out vec2 vuvCoord0 ;

void main()
{
	vec4 p = vec4(position.xyz, 1.0);
	vec3 vViewModelPosition = normalize( mtx_normal * vec4(0.0, 0.0, 0.0, 1.0) ).xyz;
	vvLocalSurfaceToViewerDirection = normalize(vViewModelPosition - p.xyz) ;

	vec4 worldp = mtx_worldview * p;
	vec4 vLightModelPosition = mtx_normal * normalize(  (vec4(light.xyz, 1.0) - worldp) );
	vvLocalSurfaceToLightDirection = normalize(vLightModelPosition.xyz) ;

	vvLocalSurfaceNormal = normalize((mtx_normal * vec4(normal, 0.0)).xyz);
	

	vec3 vLocalSurfaceToViewerDirection = normalize(vViewModelPosition - p.xyz) ;
	vvLocalReflectedSurfaceToViewerDirection = normalize(reflect(vLocalSurfaceToViewerDirection, vvLocalSurfaceNormal)) ;

	vuvCoord0 = texcoord0 ;

	gl_Position = mtx_proj * mtx_worldview * p;
}

à	Û	#version 300 es






#line 5
in highp vec4 position;
in mediump vec2 texcoord0;
in mediump vec3 normal;

uniform mediump mat4 mtx_world;
uniform mediump mat4 mtx_worldview;
uniform mediump mat4 mtx_view;
uniform mediump mat4 mtx_proj;
uniform mediump mat4 mtx_normal;
uniform mediump vec4 light;








out vec3 vvLocalSurfaceNormal ;
out vec3 vvLocalSurfaceToLightDirection;
out vec3 vvLocalReflectedSurfaceToViewerDirection;
out vec3 vvLocalSurfaceToViewerDirection;
out vec2 vuvCoord0 ;

void main()
{
	vec4 p = vec4(position.xyz, 1.0);
	vec3 vViewModelPosition = normalize( mtx_normal * vec4(0.0, 0.0, 0.0, 1.0) ).xyz;
	vvLocalSurfaceToViewerDirection = normalize(vViewModelPosition - p.xyz) ;

	vec4 worldp = mtx_worldview * p;
	vec4 vLightModelPosition = mtx_normal * normalize(  (vec4(light.xyz, 1.0) - worldp) );
	vvLocalSurfaceToLightDirection = normalize(vLightModelPosition.xyz) ;

	vvLocalSurfaceNormal = normalize((mtx_normal * vec4(normal, 0.0)).xyz);
	

	vec3 vLocalSurfaceToViewerDirection = normalize(vViewModelPosition - p.xyz) ;
	vvLocalReflectedSurfaceToViewerDirection = normalize(reflect(vLocalSurfaceToViewerDirection, vvLocalSurfaceNormal)) ;

	vuvCoord0 = texcoord0 ;

	gl_Position = mtx_proj * mtx_worldview * p;
}

‘Œ// Positions can be world or local space, since world and normal
// matrices are identity for world vertex space materials.
// If world vertex space is selected, you can remove the
// normal matrix multiplication for optimal performance.


precision mediump float;
#line 5
attribute highp vec4 position;
attribute mediump vec2 texcoord0;
attribute mediump vec3 normal;

uniform mediump mat4 mtx_world;
uniform mediump mat4 mtx_worldview;
uniform mediump mat4 mtx_view;
uniform mediump mat4 mtx_proj;
uniform mediump mat4 mtx_normal;
uniform mediump vec4 light;

//uniform mediump vec4 camPos;

// Original work by Martia A Saunders
// https://dominium.maksw.com/articles/physically-based-rendering-pbr/pbr-part-one/

// attribute vec3 aVertexTangent;

varying vec3 vvLocalSurfaceNormal ;
varying vec3 vvLocalSurfaceToLightDirection;
varying vec3 vvLocalReflectedSurfaceToViewerDirection;
varying vec3 vvLocalSurfaceToViewerDirection;
varying vec2 vuvCoord0 ;

void main()
{
	vec4 p = vec4(position.xyz, 1.0);
	vec3 vViewModelPosition = normalize( mtx_normal * vec4(0.0, 0.0, 0.0, 1.0) ).xyz;
	vvLocalSurfaceToViewerDirection = normalize(vViewModelPosition - p.xyz) ;

	vec4 worldp = mtx_worldview * p;
	vec4 vLightModelPosition = mtx_normal * normalize(  (vec4(light.xyz, 1.0) - worldp) );
	vvLocalSurfaceToLightDirection = normalize(vLightModelPosition.xyz) ;

	vvLocalSurfaceNormal = normalize((mtx_normal * vec4(normal, 0.0)).xyz);
	//vvLocalSurfaceNormal = normalize(normal) ; // use the actual normal from the actual geometry

	vec3 vLocalSurfaceToViewerDirection = normalize(vViewModelPosition - p.xyz) ;
	vvLocalReflectedSurfaceToViewerDirection = normalize(reflect(vLocalSurfaceToViewerDirection, vvLocalSurfaceNormal)) ;

	vuvCoord0 = texcoord0 ;

	gl_Position = mtx_proj * mtx_worldview * p;
}
